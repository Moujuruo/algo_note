/*
 * @lc app=leetcode.cn id=928 lang=cpp
 * @lcpr version=30122
 *
 * [928] 尽量减少恶意软件的传播 II
 */


// @lcpr-template-start
using namespace std;
#include <algorithm>
#include <array>
#include <bitset>
#include <climits>
#include <deque>
#include <functional>
#include <iostream>
#include <list>
#include <queue>
#include <stack>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
// @lcpr-template-end
// @lc code=start
class Solution {
public:
    static const int N = 501;
    int fa[N], sz[N];

    int find(int x) {
        if (fa[x] == x) return x;
        return fa[x] = find(fa[x]);
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        for (int i = 0; i < n; i++) {
            fa[i] = i;
            sz[i] = 1;
        }
        sort(initial.begin(), initial.end());
        unordered_set<int> malwares(initial.begin(), initial.end());
        for (int i = 0; i < n; i++) {
            if (malwares.count(i)) continue;
            for (int j = i + 1; j < n; j++) {
                if (malwares.count(j)) continue;
                if (graph[i][j]) {
                    int fx = find(i), fy = find(j);
                    if (fx != fy) {
                        fa[fx] = fy;
                        sz[fy] += sz[fx];
                    }
                }
            }
        }
        vector<int> total(n, 0), cnt(n, 0);
        for (int i: initial) {
            unordered_set<int> points;
            for (int j = 0; j < n; j++) {
                if (graph[i][j] && !malwares.count(j)) {
                    int f = find(j);
                    if (!points.count(f)) {
                        points.insert(f);
                        cnt[f] ++;
                        // total[i] += sz[f];
                    }
                }
            }
        }        
        for (int i: initial) {
            unordered_set<int> points;
            for (int j = 0; j < n; j++) {
                if (graph[i][j] && !malwares.count(j)) {
                    int f = find(j);
                    if (!points.count(f) && cnt[f] == 1) {
                        points.insert(f);
                        cnt[f] ++;
                        total[i] += sz[f];
                    }
                }
            }
        }

        int ans = -1, ans_sz = 0;
        for (int i: initial) {
            if (ans_sz < total[i] || (ans_sz == total[i] && i < ans)) {
                ans_sz = total[i];
                ans = i;
            }
        }
        if (ans == -1)
            ans = initial[0];
        return ans;
    }
};
// @lc code=end



/*
// @lcpr case=start
// [[1,1,0],[1,1,0],[0,0,1]]\n[0,1]\n
// @lcpr case=end

// @lcpr case=start
// [[1,1,0],[1,1,1],[0,1,1]]\n[0,1]\n
// @lcpr case=end

// @lcpr case=start
// [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]\n[0,1]\n
// @lcpr case=end

 */

